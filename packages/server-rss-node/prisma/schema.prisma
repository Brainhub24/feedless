generator client {
  provider = "prisma-client-js"
}

generator typegraphql {
  provider = "typegraphql-prisma"
}

datasource db {
  provider = "mysql"
  //  url      = "mysql://root:admin@local.worker:3306/rich-rss"
  url      = env("DATABASE_URL")
}

model User {
  id           String          @id @default(uuid())
  email        String          @unique
  name         String
  buckets      Bucket[]
  articleRefs  ArticleRef[]
  notebooks    Notebook[]
  subscription Subscription[]
  settings     ProfileSettings @relation(fields: [settingsId], references: [id])
  settingsId   String

  ownedFeeds Feed[]
  eventHooks EventHook[]
  Comment    Comment[]
}

model EventHook {
  id                String  @id @default(uuid())
  owner             User    @relation(fields: [ownerId], references: [id])
  ownerId           String
  event             String
  type              String
  script_or_url     String  @db.Text
  script_source_url String? @unique @db.VarChar(500)
}

model ProfileSettings {
  id              String  @id @default(uuid())
  useFulltext     Boolean @default(false)
  useBetterRead   Boolean @default(false)
  showNativeTags  Boolean @default(true)
  showContentTags Boolean @default(true)
  queryEngines    Json?

  user User?
}

model Notebook {
  id          String   @id @default(uuid())
  name        String
  description String   @default("")
  readonly    Boolean  @default(false)
  listed      Boolean  @default(false)
  stream      Stream   @relation(fields: [streamId], references: [id])
  streamId    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now()) @updatedAt
  owner       User     @relation(fields: [ownerId], references: [id])
  ownerId     String

  @@unique([name, ownerId])
}

model Feed {
  id                     String         @id @default(uuid())
  feed_url               String         @db.VarChar(500)
  home_page_url          String?
  /// @TypeGraphQL.omit(output: true)
  fulltext_data          String?        @db.Text
  /// @TypeGraphQL.omit(output: true)
  domain                 String
  title                  String?
  lang                   String?
  tags                   Json?
  enclosures             Json?
  author                 String?
  is_private             Boolean        @default(false)
  //  retention_content_filter String?
  //  retention_size           Int?
  owner                  User           @relation(fields: [ownerId], references: [id])
  ownerId                String         @default("system")
  expired                Boolean        @default(false)
  broken                 Boolean        @default(false)
  inactive               Boolean        @default(false)
  description            String?        @db.Text
  status                 String         @default("unresolved") // SourceStatus
  /// @TypeGraphQL.omit(output: true)
  harvestIntervalMinutes Int?
  /// @TypeGraphQL.omit(output: true)
  nextHarvestAt          DateTime?
  stream                 Stream         @relation(fields: [streamId], references: [id])
  streamId               String
  /// @TypeGraphQL.omit(output: true)
  subscriptions          Subscription[]
  /// @TypeGraphQL.omit(output: true)
  createdAt              DateTime       @default(now())
  lastUpdatedAt          DateTime?
  events                 FeedEvent[]

  @@unique([feed_url, ownerId])
}

model FeedEvent {
  id        String   @id @default(uuid())
  message   Json
  feed      Feed     @relation(fields: [feedId], references: [id])
  feedId    String
  createdAt DateTime @default(now())
  is_error  Boolean  @default(false)
}

model Stream {
  id          String       @id @default(uuid())
  articleRefs ArticleRef[]
  feeds       Feed[]
  buckets     Bucket[]
  notebooks   Notebook[]
}

model ArticleRef {
  id            String       @id @default(uuid())
  createdAt     DateTime     @default(now())
  /// @TypeGraphQL.omit(output: true)
  updatedAt     DateTime     @default(now()) @updatedAt
  date_released DateTime     @default(now())
  owner         User         @relation(fields: [ownerId], references: [id])
  ownerId       String       @default("system")
  favored       Boolean      @default(false)
  has_seen      Boolean      @default(false)
  tags          Json?
  article       Article      @relation(fields: [articleId], references: [id])
  articleId     String
  related       ArticleRef[] @relation("ArticleRefToArticleRef")
  articleRef    ArticleRef?  @relation("ArticleRefToArticleRef", fields: [articleRefId], references: [id])
  articleRefId  String?
  stream        Stream[]
}

model Article {
  id                  String       @id @default(uuid())
  /// @TypeGraphQL.omit(output: true)
  createdAt           DateTime     @default(now())
  updatedAt           DateTime     @default(now())
  released            Boolean      @default(true)
  applyPostProcessors Boolean      @default(true) // articles from post processors don't trigger post processing
  date_published      DateTime     @default(now())
  date_modified       DateTime?
  comment_feed_url    String?
  source_url          String?      @db.VarChar(500)
  url                 String?      @unique @db.VarChar(500)
  author              String?
  title               String       @db.VarChar(200)
  tags                Json?
  score               Float?       @default(0)
  lastScoredAt        DateTime     @default(now())
  fulltext_data       String?      @db.LongText
  content_raw_mime    String?      @db.VarChar(50)
  content_raw         String       @db.LongText
  content_text        String?      @db.LongText
  enclosure           Json?
  articleRef          ArticleRef[]
  data_json_map       Json?
  readability         Json?
  has_readability     Boolean?
  comments            Comment[]
}

model Bucket {
  id            String    @id @default(uuid())
  title         String
  description   String?   @db.Text
  listed        Boolean   @default(false)
  tags          Json?
  in_focus      Boolean   @default(true)
  lastUpdatedAt DateTime?
  filter        String?

  owner         User           @relation(fields: [ownerId], references: [id])
  ownerId       String
  subscriptions Subscription[]

  lastPostProcessedAt DateTime               @default(now())
  postProcessors      ArticlePostProcessor[]

  createdAt DateTime @default(now())
  stream    Stream   @relation(fields: [streamId], references: [id])
  streamId  String

  trigger_refresh_on        String    @default("change") // subscription change, scheduled
  trigger_scheduled_last_at DateTime?
  trigger_scheduled_next_at DateTime?
  trigger_scheduled         String?

  segment_sort_field String?
  segment_sort_asc   Boolean @default(true) // natuarl order
  segment_size       Int     @default(10)
}

model NoFollowUrl {
  id         String @id @default(uuid())
  url_prefix String @unique
}

model Comment {
  id               String    @id @default(uuid())
  root             Article   @relation(fields: [rootId], references: [id])
  rootId           String
  //    parent    Comment?   @relation(fields: [parentId], references: [id])
  //    parentId  String?
  children         Comment[] @relation("CommentToComment")
  owner            User      @relation(fields: [ownerId], references: [id])
  ownerId          String
  content_raw_mime String    @default("text/markdown") @db.VarChar(50)
  content_raw      String    @db.LongText
  content_html     String    @db.LongText

  Comment   Comment? @relation("CommentToComment", fields: [commentId], references: [id])
  commentId String?
}

model ArticlePostProcessor {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
  type      String   @unique
  context   Json?
  buckets   Bucket[]
}

model Subscription {
  id            String    @id @default(uuid())
  inactive      Boolean   @default(false)
  createdAt     DateTime  @default(now())
  lastUpdatedAt DateTime?
  title         String
  tags          Json?
  feed          Feed      @relation(fields: [feedId], references: [id])
  feedId        String
  owner         User      @relation(fields: [ownerId], references: [id])
  ownerId       String
  bucket        Bucket    @relation(fields: [bucketId], references: [id])
  bucketId      String
}
