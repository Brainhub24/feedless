generator client {
  provider = "prisma-client-js"
}

generator typegraphql {
  provider = "typegraphql-prisma"
}

datasource db {
  provider = "postgresql"
  //  url      = "mysql://root:admin@local.worker:3306/rich-rss"
  url      = env("DATABASE_URL")
}

model User {
  id           String          @id @default(uuid())
  email        String          @unique
  name         String
  buckets      Bucket[]
  articleRefs  ArticleRef[]
  notebooks    Notebook[]
  subscription Subscription[]
  settings     ProfileSettings @relation(fields: [settingsId], references: [id])
  settingsId   String

  ownedFeeds Feed[]
  eventHooks EventHook[]
}

model EventHook {
  id                String  @id @default(uuid())
  owner             User    @relation(fields: [ownerId], references: [id])
  ownerId           String
  event             String
  type              String
  script_or_url     String  @db.Text
  script_source_url String? @unique @db.VarChar(500)
}

model ProfileSettings {
  id              String  @id @default(uuid())
  useFulltext     Boolean @default(false)
  useBetterRead   Boolean @default(false)
  showNativeTags  Boolean @default(true)
  showContentTags Boolean @default(true)
  queryEngines    Json?

  user User?
}

model Notebook {
  id          String   @id @default(uuid())
  name        String
  description String   @default("")
  readonly    Boolean  @default(false)
  listed      Boolean  @default(false)
  stream      Stream   @relation(fields: [streamId], references: [id])
  streamId    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now()) @updatedAt
  owner       User     @relation(fields: [ownerId], references: [id])
  ownerId     String

  @@unique([name, ownerId])
}

model Feed {
  id                     String    @id @default(uuid())
  feed_url               String    @db.VarChar(500)
  home_page_url          String?
  /// @TypeGraphQL.omit(output: true)
  domain                 String
  title                  String?
  lang                   String?
  tags                   Json?
  author                 String?
  is_private             Boolean   @default(false)
  owner                  User      @relation(fields: [ownerId], references: [id])
  ownerId                String    @default("system")
  expired                Boolean   @default(false)
  broken                 Boolean   @default(false)
  inactive               Boolean   @default(false)
  filter                 String?
  description            String?   @db.Text
  status                 String    @default("unresolved") // SourceStatus
  /// @TypeGraphQL.omit(output: true)
  harvestIntervalMinutes Int?
  /// @TypeGraphQL.omit(output: true)
  nextHarvestAt          DateTime?
  retention_size         Int?
  harvest_site           Boolean   @default(true)
  allowHarvestFailure    Boolean   @default(false)
  harvest_prerender      Boolean   @default(false)

  stream        Stream         @relation(fields: [streamId], references: [id])
  streamId      String
  /// @TypeGraphQL.omit(output: true)
  subscriptions Subscription[]
  /// @TypeGraphQL.omit(output: true)
  createdAt     DateTime       @default(now())
  lastUpdatedAt DateTime?
  events        FeedEvent[]

  @@unique([feed_url, ownerId])
}

model FeedEvent {
  id        String   @id @default(uuid())
  message   String
  feed      Feed     @relation(fields: [feedId], references: [id])
  feedId    String
  createdAt DateTime @default(now())
  is_error  Boolean  @default(false)
}

model Stream {
  id          String       @id @default(uuid())
  articleRefs ArticleRef[]
  feeds       Feed[]
  buckets     Bucket[]
  notebooks   Notebook[]
}

model ReferencedArticleRef {
  source         ArticleRef @relation("source", fields: [sourceId], references: [id])
  sourceId       String
  target         ArticleRef @relation("target", fields: [targetId], references: [id])
  targetId       String
  reference_type String // child/parent

  @@id([sourceId, targetId])
}

model ArticleRef {
  id            String                 @id @default(uuid())
  createdAt     DateTime               @default(now())
  /// @TypeGraphQL.omit(output: true)
  updatedAt     DateTime               @default(now()) @updatedAt
  date_released DateTime               @default(now())
  owner         User                   @relation(fields: [ownerId], references: [id])
  ownerId       String                 @default("system")
  favored       Boolean                @default(false)
  has_seen      Boolean                @default(false)
  tags          Json?
  data          Json?
  article       Article                @relation(fields: [articleId], references: [id])
  articleId     String
  type          String                 @default("feed") // comment/feed/quote
  relatives_out ReferencedArticleRef[] @relation("source")
  relatives_in  ReferencedArticleRef[] @relation("target")
  stream        Stream[]
  //  parent
  //  root
}

// shared article
model Article {
  id               String    @id @default(uuid())
  /// @TypeGraphQL.omit(output: true)
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @default(now())
  released         Boolean   @default(true)
  date_published   DateTime  @default(now())
  date_modified    DateTime?
  comment_feed_url String?
  source_url       String?   @db.VarChar(500)
  url              String?   @unique @db.VarChar(500)
  author           String?
  title            String    @db.VarChar(200)
  tags             Json?
  fulltext_data    String?   @db.VarChar(500)
  content_raw_mime String?   @db.VarChar(50)
  content_raw      String    @db.Text
  content_text     String?   @db.Text

  has_harvest     Boolean?
  has_readability Boolean?
  has_video       Boolean  @default(false)
  has_audio       Boolean  @default(false)
  length_video    Int?
  length_audio    Int?
  word_count_text Int?
  score           Float?   @default(0)
  lastScoredAt    DateTime @default(now())

  enclosure     Json?
  articleRef    ArticleRef[]
  data_json_map Json?
  readability   Json?
}

model Bucket {
  id          String  @id @default(uuid())
  title       String
  description String? @db.Text
  listed      Boolean @default(false)
  tags        Json?
  in_focus    Boolean @default(true)

  owner         User           @relation(fields: [ownerId], references: [id])
  ownerId       String
  subscriptions Subscription[]

  lastPostProcessedAt DateTime               @default(now())
  postProcessors      ArticlePostProcessor[]
  exporters           ArticleExporter[]

  createdAt DateTime @default(now())
  stream    Stream   @relation(fields: [streamId], references: [id])
  streamId  String
}

model ArticleExporter {
  id                 String   @id @default(uuid())
  segment            Boolean  @default(false)
  segment_sort_field String?
  segment_sort_asc   Boolean  @default(true) // natuarl order
  segment_size       Int?
  segment_digest     Boolean?

  lastUpdatedAt DateTime?

  trigger_refresh_on        String    @default("change") // subscription change, scheduled
  trigger_scheduled_last_at DateTime?
  trigger_scheduled_next_at DateTime?
  trigger_scheduled         String?

  targets  ArticleExporterTarget[]
  bucket   Bucket                  @relation(fields: [bucketId], references: [id])
  bucketId String
}

model ArticleExporterTarget {
  id             String  @id @default(uuid())
  type           String
  context        String?
  forward_errors Boolean @default(false)

  exporter   ArticleExporter @relation(fields: [exporterId], references: [id])
  exporterId String
}

model NoFollowUrl {
  id         String @id @default(uuid())
  url_prefix String @unique
}

//model Comment {
//  id               String    @id @default(uuid())
//  root             Article   @relation(fields: [rootId], references: [id])
//  rootId           String
//  //    parent    Comment?   @relation(fields: [parentId], references: [id])
//  //    parentId  String?
//  children         Comment[] @relation("CommentToComment")
//  owner            User      @relation(fields: [ownerId], references: [id])
//  ownerId          String
//  content_raw_mime String    @default("text/markdown") @db.VarChar(50)
//  content_raw      String    @db.Text
//  content_html     String    @db.Text
//
//  Comment   Comment? @relation("CommentToComment", fields: [commentId], references: [id])
//  commentId String?
//}

model ArticlePostProcessor {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
  type      String   @unique
  context   String?
  buckets   Bucket[]
}

model Subscription {
  id            String    @id @default(uuid())
  inactive      Boolean   @default(false)
  createdAt     DateTime  @default(now())
  lastUpdatedAt DateTime?
  title         String
  tags          Json?
  feed          Feed      @relation(fields: [feedId], references: [id])
  feedId        String
  owner         User      @relation(fields: [ownerId], references: [id])
  ownerId       String
  bucket        Bucket    @relation(fields: [bucketId], references: [id])
  bucketId      String
}
