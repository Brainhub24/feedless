scalar DateTime
scalar JSON
scalar Long

enum ArticleReleaseStatus {
  released,
  unreleased,
  dropped
}

enum ArticleType {
  feed,
  ops
}

enum Visibility {
  isPublic,
  isProtected,
  isHidden
}

enum SortOrder {
  desc, asc
}

enum SortField {
  publishedAt,
}

interface Paginated {
  pagination: Pagination!
}

interface Entity {
  id: ID!
  createdAt: Long!
}

type Subscription {
  authViaMail(email: String!): AuthenticationEvent!
}

type AuthenticationEvent {
  authentication: Authentication
  message: AuthenticationEventMessage
  confirmCode: ConfirmCode
}

type AuthenticationEventMessage {
  isError: Boolean!
  message: String!
}

type ConfirmCode {
  otpId: ID!
  length: Int!
}

type Authentication {
  token: String!
  corrId: String!
}

type Query {
  serverSettings: ServerSettings!
  article(data: ArticleWhereInput!): Article!
  content(data: ContentWhereInput!): Content!
  nativeFeed(data: NativeFeedWhereInput!): NativeFeed!
  genericFeed(data: GenericFeedWhereInput!): GenericFeed!
  bucket(data: BucketWhereInput!): Bucket!
  importer(data: ImporterWhereInput!): Importer!
  articles(data: ArticlesPagedInput!): PagedArticlesResponse!
  discoverFeeds(data: DiscoverFeedsInput!): FeedDiscoveryResponse!
  buckets(data: BucketsPagedInput!): PagedBucketsResponse!
  nativeFeeds(data: NativeFeedsPagedInput!): PagedNativeFeedsResponse!
  genericFeeds(data: GenericFeedsPagedInput!): PagedGenericFeedsResponse!
  remoteNativeFeed(nativeFeedUrl: String!): RemoteNativeFeed!
  profile: Profile!
  plans: [Plan!]!
}

type Profile {
  minimalFeatureState: FeatureState!
  preferFulltext: Boolean!
  isLoggedIn: Boolean!
  isAnonymous: Boolean!
  dateFormat: String
  timeFormat: String
  user: User
  preferReader: Boolean!
  featuresOverwrites: [Feature!]!
}

type Plan {
  planName: PlanName!
  isPrimary: Boolean!
  availability: PlanAvailability!
  costs: Float!
  features: [Feature!]!
}

enum PlanAvailability {
  available,
  by_request,
  unavailable
}

enum PlanName {
  free,
  basic
}

type ServerSettings {
  apiUrls: ApiUrls!
  features: [Feature!]!
}

type ApiUrls {
  webToFeed: String!
}

type Feature {
  state: FeatureState!
  name: FeatureName!
  value: FeatureValue
}

type FeatureValue {
  boolVal: FeatureBooleanValue
  numVal: FeatureIntValue
}

type FeatureIntValue {
  value: Int!
}

type FeatureBooleanValue {
  value: Boolean!
}

enum FeatureState {
  off,
  experimental,
  beta,
  stable
}

enum FeatureName {
  database,
  elasticsearch,
  puppeteer,
  authentication,
  authenticated,
  authAllowRoot,
  authSSO,
  authMail,
#
  rateLimit,
  notifications,
  feedsMaxRefreshRate,
  bucketsMaxCount,
  bucketsAccessOther,
  feedsMaxCount,
  feedsFulltext,
  itemsInlineImages,

  genFeedFromWebsite,
  genFeedFromFeed,
  genFeedFromPageChange,
  genFeedWithPrerender,
  genFeedWithPuppeteerScript,

  itemsNoUrlShortener,
  itemsRetention,
  feedsPrivateAccess,
  bucketsPrivateAccess,
  feedAuthentication,
  itemEmailForward,
  itemWebhookForward,
  api
}

input BucketWhereInput {
  where: BucketUniqueWhereInput!
}

input GenericFeedWhereInput {
  where: GenericFeedUniqueWhereInput!
}

input NativeFeedWhereInput {
  where: NativeFeedUniqueWhereInput!
}

input ContentWhereInput {
  where: ContentUniqueWhereInput!
}

input ArticleWhereInput {
  where: ArticleUniqueWhereInput!
}

type ArticleContext {
  articleId: ID!
  articles(page: Int!): [Article!]!
  links(page: Int!): [WebDocument!]!
  #  buckets(page: Int!): [Bucket!]
  #  nativeFeeds(page: Int!): [NativeFeed!]
}

type WebDocument {
  id: ID!
  title: String!
  description: String
  type: String!
  url: String!
  imageUrl: String
  score: Float
  createdAt: Long!
}

type Mutation {
  authAnonymous: Authentication!
  authConfirmCode(data: ConfirmAuthCodeInput!): Boolean!

  createArticle(data: ArticleCreateInput!): Article!
  updateArticle(data: ArticleUpdateWhereInput!): Article!
  deleteArticle(data: ArticleDeleteWhereInput!): Article!

  createBucket(data: BucketCreateInput!): Bucket!
  updateBucket(data: BucketUpdateInput!): Bucket!
  deleteBucket(data: BucketDeleteInput!): Boolean!

  createImporter(data: ImporterCreateInput!): Importer!
  updateImporter(data: ImporterUpdateInput!): Importer!
  deleteImporter(data: ImporterDeleteInput!): Boolean!

  createNativeFeed(data: NativeFeedCreateInput!): NativeFeed!
  updateNativeFeed(data: NativeFeedUpdateInput!): NativeFeed!
  deleteNativeFeed(data: NativeFeedDeleteInput!): Boolean!

  createGenericFeed(data: GenericFeedCreateInput!): GenericFeed!
  updateGenericFeed(data: GenericFeedUpdateInput!): GenericFeed!
  deleteGenericFeed(data: GenericFeedDeleteInput!): Boolean!

  importOpml(data: ImportOpmlInput!): ImportOpmlResponse!
  exportOpml: ExportOpmlResponse!
  acceptTermsAndConditions: Boolean!
  logout: Boolean
}

input ConfirmAuthCodeInput {
  code: String!
  otpId: ID!
}

type ExportOpmlResponse {
  data: String!
}

type ImportOpmlResponse {
  success: Boolean!
}

input ImportOpmlInput {
  data: String!
}

input ArticleDeleteWhereInput {
  where: ArticleUniqueWhereInput!
}

input ArticleUpdateWhereInput {
  where: ArticleUniqueWhereInput!
  data: ArticleInput!
}

input ArticleInput {
  title: String!
}

input ArticleCreateInput {
  data: ArticleCreateOrConnectInput!
  reference: BucketOrNativeFeedOrArticleWhereInput
}

input BucketOrNativeFeedOrArticleWhereInput {
  article: ArticleUniqueWhereInput
  bucket: BucketUniqueWhereInput
  nativeFeed: NativeFeedUniqueWhereInput
}

input NativeFeedUniqueWhereInput {
  id: ID!
}

input BucketUniqueWhereInput {
  id: ID!
}

input ArticleCreateOrConnectInput {
  create: ArticleInput
  connect: ArticleUniqueWhereInput
}

input ArticleUniqueWhereInput {
  id: ID!
}

input ContentUniqueWhereInput {
  id: ID!
}

input ImporterWhereInput {
  importer: ImporterUniqueWhereInput
  bucketAndFeed: ImporterWhereBucketAndFeedInput
}

input ImporterWhereBucketAndFeedInput {
  bucket: BucketUniqueWhereInput!
  nativeFeed: NativeFeedUniqueWhereInput!
}

input GenericFeedDeleteInput {
  genericFeed: GenericFeedUniqueWhereInput!
}

input GenericFeedUniqueWhereInput {
  id: ID!
}

input NativeFeedDeleteInput {
  nativeFeed: NativeFeedUniqueWhereInput!
}

input ImporterDeleteInput {
  where: ImporterUniqueWhereInput!
}
input ImporterUniqueWhereInput {
  id: ID!
}

input BucketDeleteInput {
  where: BucketUniqueWhereInput!
}

input GenericFeedCreateInput {
  specification: GenericFeedSpecificationInput!
  title: String!
  description: String
  websiteUrl: String!
  language: String
  harvestItems: Boolean!
  harvestSiteWithPrerender: Boolean!
}

input GenericFeedUpdateInput {
  data: GenericFeedUpdateDataInput!
  where: GenericFeedUniqueWhereInput!
}

input GenericFeedUpdateDataInput {
  specification: GenericFeedSpecificationInput!
  title: StringUpdateOperationsInput
  description: NullableStringUpdateOperationsInput
  websiteUrl: StringUpdateOperationsInput
  harvestSiteWithPrerender: BoolUpdateOperationsInput
}

input GenericFeedSpecificationInput {
  selectors: SelectorsInput!
  parserOptions: ParserOptionsInput!
  fetchOptions: FetchOptionsInput!,
  refineOptions: RefineOptionsInput!
}

type GenericFeedSpecification {
  selectors: Selectors!
  parserOptions: ParserOptions!
  fetchOptions: FetchOptions!,
  refineOptions: RefineOptions!
}

enum ExtendContentOptions {
  PREVIOUS,
  NEXT,
  NONE,
  PREVIOUS_AND_NEXT
}

input SelectorsInput {
  linkXPath: String!
  extendContext: ExtendContentOptions!
  contextXPath: String!
  dateXPath: String!
  paginationXPath: String!
  dateIsStartOfEvent: Boolean!
}

type Selectors {
  linkXPath: String!
  extendContext: ExtendContentOptions!
  contextXPath: String!
  paginationXPath: String!
  dateXPath: String!
  dateIsStartOfEvent: Boolean!
}

input ImporterCreateInput {
  feed: NativeFeedCreateOrConnectInput!
  bucket: BucketCreateOrConnectInput!
  autoRelease: Boolean!
  filter: String # should be a ref to be reused
  email: String
  webhook: String
}

input ImporterUpdateInput {
  feed: NativeFeedCreateOrConnectInput!
  bucket: BucketCreateOrConnectInput!
  autoRelease: BoolUpdateOperationsInput
  filter: NullableStringUpdateOperationsInput # should be a ref to be reused
  where: ImporterUniqueWhereInput!
}

input NativeFeedCreateOrConnectInput {
  connect: NativeFeedUniqueWhereInput
  create: NativeOrGenericFeedCreateInput
}

input BucketCreateOrConnectInput {
  connect: BucketUniqueWhereInput
  create: BucketCreateInput
}

input NativeOrGenericFeedCreateInput {
  nativeFeed: NativeFeedCreateInput
  genericFeed: GenericFeedCreateInput
}

input BucketsPagedInput {
  page: Int!
  where: BucketsWhereInput
  orderBy: BucketsOrderByInput
}

input BucketsOrderByInput {
  createdAt: SortOrder
  updatedAt: SortOrder
  title: SortOrder
}

input NativeFeedsPagedInput {
  page: Int!
  where: NativeFeedsWhereInput!
  orderBy: NativeFeedsOrderByInput
}

input GenericFeedsPagedInput {
  page: Int!
  where: GenericFeedsWhereInput!
}

input NativeFeedsOrderByInput {
  publishedAt: SortOrder
  createdAt: SortOrder
  title: SortOrder
}

input NativeFeedsWhereInput {
  query: String
  feedUrl: String
}

input GenericFeedsWhereInput {
  websiteUrl: String
}

input BucketsWhereInput {
  query: String
  ownerId: ID
  visibility: Visibility
}

input DiscoverFeedsInput {
  parserOptions: ParserOptionsInput!
  fetchOptions: FetchOptionsInput!
}

input ParserOptionsInput {
  strictMode: Boolean!
}

input ArticlesInBucketInput {
  bucketId: String!
  filter: ArticlesWhereInput
}

input ArticlesPagedInput {
  page: Int!
  where: ArticlesWhereInput!
  orderBy: ArticlesOrderByInput
}

input ArticlesOrderByInput {
  releasedAt: SortOrder!
}

input ArticlesWhereInput {
  streamId: String!
  query: String
  type: ArticleTypeFilterInput
  status: ArticleReleaseStatusFilterInput
}

input ArticleReleaseStatusFilterInput {
  oneOf: [ArticleReleaseStatus!]!
}

input ArticleTypeFilterInput {
  oneOf: [ArticleType!]!
}

input BucketCreateInput {
  name: String!
  description: String!
  websiteUrl: String
  imageUrl: String
  visibility: Visibility!
  tags: String
}

input BucketUpdateInput {
  where: BucketUniqueWhereInput!
  data: BucketUpdateDataInput!
}

input BucketUpdateDataInput {
  name: NullableStringUpdateOperationsInput
  description: NullableStringUpdateOperationsInput
  websiteUrl: NullableStringUpdateOperationsInput
  imageUrl: NullableStringUpdateOperationsInput
  visibility: VisibilityUpdateOperationsInput
  tags: NullableStringArrayUpdateOperationsInput
}

input NullableStringUpdateOperationsInput {
  set: String
}

input NullableLongUpdateOperationsInput {
  set: Long
}

input StringUpdateOperationsInput {
  set: String!
}

input NullableBoolUpdateOperationsInput {
  set: Boolean
}
input BoolUpdateOperationsInput {
  set: Boolean!
}

input NullableStringArrayUpdateOperationsInput {
  set: [String!]
}

input NativeFeedCreateInput {
  websiteUrl: String!
  imageUrl: String
  language: String
  feedUrl: String!
  title: String!
  description: String
  lat: Long
  lon: Long
  autoRelease: Boolean!
  harvestItems: Boolean!
  harvestSiteWithPrerender: Boolean!
  visibility: Visibility!
}

input NativeFeedUpdateInput {
  id: ID!
  websiteUrl: StringUpdateOperationsInput
  imageUrl: NullableStringUpdateOperationsInput
  language: NullableStringUpdateOperationsInput
  feedUrl: StringUpdateOperationsInput
  title: StringUpdateOperationsInput
  description: NullableStringUpdateOperationsInput
  lat: NullableLongUpdateOperationsInput
  lon: NullableLongUpdateOperationsInput
  autoRelease: BoolUpdateOperationsInput
  harvestItems: BoolUpdateOperationsInput
  harvestSiteWithPrerender: BoolUpdateOperationsInput
  visibility: VisibilityUpdateOperationsInput!
}

input VisibilityUpdateOperationsInput {
  set: Visibility!
}


type RemoteNativeFeed {
  title: String!
  description: String
  author: String
  websiteUrl: String
  language: String
  items: [Content!],
  feedUrl: String!
  publishedAt: Long!
  expired: Boolean!
}

type PagedBucketsResponse implements Paginated {
  pagination: Pagination!
  buckets: [Bucket!]!
}

type PagedNativeFeedsResponse implements Paginated {
  nativeFeeds: [NativeFeed!]!
  pagination: Pagination!
}

type PagedGenericFeedsResponse implements Paginated {
  genericFeeds: [GenericFeed!]!
  pagination: Pagination!
}

type PagedArticlesResponse implements Paginated {
  articles: [Article!]!
  pagination: Pagination!
}

type Pagination {
  page: Int!
#  totalPages: Int!
#  totalElements: Long!
  isLast: Boolean!
  isEmpty: Boolean!
  isFirst: Boolean!
}

type GenericFeed implements Entity {
  id: ID!
  specification: GenericFeedSpecification!
  feedUrl: String!
  hash: String!
  nativeFeedId: ID!
  createdAt: Long!
  #  nativeFeed: NativeFeed!
}

type NativeFeed implements Entity {
  id: ID!
  createdAt: Long!
  domain: String
  websiteUrl: String
  imageUrl: String
  iconUrl: String
  feedUrl: String!
  title: String!
  description: String
  streamId: String!
  status: String!
  autoRelease: Boolean!
  genericFeed: GenericFeed
  lastUpdatedAt: Long
#  nextRefreshAt: Long
  visibility: Visibility!
  lat: Long
  lon: Long
  importers: [Importer!]!
  #  importersCount: Long!
}

type Bucket implements Entity {
  id: ID!
  createdAt: Long!
  title: String!
  tags: String
  description: String!
  websiteUrl: String
  imageUrl: String
  visibility: Visibility!
  streamId: String!
  #  articles(filter: ArticlesWhereInput!): PagedArticlesResponse!
  lastUpdatedAt: Long
  importers: [Importer!]
  #  owner
}

type Importer implements Entity {
  id: ID!
  createdAt: Long!
  autoRelease: Boolean!
  filter: String
  email: String
  webhook: String
  nativeFeedId: ID!
  nativeFeed: NativeFeed!
  bucketId: ID!
  bucket: Bucket!
}

type Enclosure {
  length: Float
  type: String!
  url: String!
}

type Article implements Entity {
  id: ID!
  createdAt: Long!
  status: ArticleReleaseStatus!
  contentId: ID!
  streamId: ID!
  nativeFeedId: ID!
  bucket: Bucket
  context: ArticleContext!
  nativeFeed: NativeFeed!
  content: Content!
  type: ArticleType!
}

type Content implements Entity {
  id: ID!
  createdAt: Long!
  title: String!
  description: String!
  contentTitle: String
  contentText: String
  contentRaw: String
  contentRawMime: String
  url: String!
  imageUrl: String
  publishedAt: Long!
  startingAt: Long
  updatedAt: Long!
  tags: [String]
  enclosures: [Enclosure!]
}

type FeedDiscoveryResponse {
  genericFeeds: GenericFeeds!
  nativeFeeds: [TransientNativeFeed!]
  #  relatedFeeds: [NativeFeedGql]
  websiteUrl: String!
  failed: Boolean!
  errorMessage: String
  document: FeedDiscoveryDocument
}

type FeedDiscoveryDocument {
  mimeType: String
  htmlBody: String
  title: String
  description: String
  language: String
  imageUrl: String
  favicon: String
}

type GenericFeeds {
  feeds: [TransientGenericFeed!]!
  parserOptions: ParserOptions!
  fetchOptions: FetchOptions!
}

type FetchOptions {
  websiteUrl: String!
  prerender: Boolean!
  prerenderWaitUntil: PuppeteerWaitUntil!
  prerenderWithoutMedia: Boolean!
  prerenderScript: String
}

type ParserOptions {
  strictMode: Boolean!
}

type TransientNativeFeed {
  url: String!
  type: String!
  title: String!
  description: String
}

type TransientGenericFeed {
  selectors: Selectors!
  hash: String!
  feedUrl: String!
  count: Int
  score: Float!
  samples: [Content!]!
}

input FetchOptionsInput {
  websiteUrl: String!
  prerender: Boolean!
  prerenderWaitUntil: PuppeteerWaitUntil!
  prerenderWithoutMedia: Boolean!
  prerenderScript: String
}

enum PuppeteerWaitUntil {
  networkidle0
  networkidle2
  load
  domcontentloaded
}

enum ContentSortTag {
  newest,
  oldest,
  title
}
enum ContentTypeTag {
  LONG,
  SHORT,
  AUDIO,
  VIDEO,
  FULLTEXT
}

enum ContentCategoryTag {
  kids
  sports
  commercial
  online
}

type RefineOptions {
  filter: String,
  recovery: ArticleRecoveryType!,
}

input RefineOptionsInput {
  filter: String,
  recovery: ArticleRecoveryType!,
}

enum ArticleRecoveryType {
  NONE,
  METADATA,
  FULL
}

type LoginResponse {
  token: String!
  user: User!
}

type User implements Entity {
  id: ID!
  createdAt: Long!
  email: String!
  name: String!
  acceptedTermsAndServices: Boolean!
  notificationsStreamId: ID!
}
