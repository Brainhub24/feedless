type Query {
  #  buckets(count: Int, offset: Int): [BucketGql]!
  articles(bucketId: String!): [ArticleGql]!
  discoverFeeds(url: String!, corrId: String, prerender: Boolean!): FeedDiscoveryGql
}

type Mutation {
  login(email: String!): LoginResponse
  createBucket(bucket: CreateBucketData): BucketGql
}

input CreateBucketData {
  name: String!
  description: String!
  listed: Boolean!
  releaseManually: Boolean!
  tags: [String]
  subscriptions: [SubscriptionData]
  exporters: [ExporterData]
}

input SubscriptionData {
  active: Boolean!
  feed: NativeFeedData!
}

input NativeFeedData {
  create: NativeFeedData
  link: EntityByIdData
}
input EntityByIdData {
  id: String!
}

input NativeFeedData {
  feedUrl: String!
  title: String!
  websiteUrl: String!
}

type StreamGql {
  id: ID!
}

type GenericFeedGql {
  id: ID!
}

type NativeFeedGql {
  id: ID!
  domain: String!
  websiteUrl: String!
  feedUrl: String!
  title: String!
  description: String!
  genericFeed: GenericFeedGql
}

type BucketGql {
  id: ID!
  name: String!
  description: String!
  stream: [StreamGql]
  feeds: [NativeFeedGql]
}

type EnclosureGql {
  length: Float,
  type: String!,
  url: String!
}
type ArticleGql {
  id: ID!
  title: String!
  contentRaw: String
  contentRawMime: String
  contentText: String!
  url: String!
  imageUrl: String
  publishedAt: Float!
  updatedAt: String!
  tags: [String]
  enclosures: [EnclosureGql]
}

input PaginationGql {
  page: Int!
  perPage: Int!
}

input SortGql {
  field: SortFieldGql!
  order: SortOrderGql!
}

enum SortOrderGql {
  desc, asc
}

enum SortFieldGql {
  publishedAt,

}

type FeedDiscoveryGql {
  genericFeedRules: [GenericFeedRuleGql]
  relatedFeeds: [NativeFeedGql]
  mimeType: String
  nativeFeeds: [NativeFeedGql]
  failed: Boolean!
  errorMessage: String
}

type GenericFeedRuleGql {
  linkXPath: String!
  extendContext: String!
  contextXPath: String!
  dateXPath: String
  feedUrl: String!
  count: Int!
  score: Float!
}

type FeedReferenceGql {
  websiteUrl: String
  feedUrl: String!
  title: String!
  description: String
  lastUpdatedAt: Float
}

type LoginResponse {
   token: String!
}
