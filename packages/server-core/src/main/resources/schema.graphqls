scalar DateTime
scalar JSON
scalar Long

enum ReleaseStatus {
  released,
  needs_approval
}

enum ArticleType {
  digest
  feed
}

type Query {
  article(id: ID!): Article!
  nativeFeed(id: ID!): NativeFeed!
  genericFeed(id: ID!): GenericFeed!
  bucketById(data: BucketByIdInput!): BucketResponse!
  articlesByStreamId(filter: ArticlesByStreamIdFilterInput!): ArticlesByStreamIdResponse!
  discoverFeeds(data: DiscoverFeedsInput!): FeedDiscoveryResponse!
  #  subscriptions: [SubscriptionGql!]!
  search(data: SearchInput!): SearchResponse
}

input BucketByIdInput {
  id: ID!
}

type Mutation {
  login(email: String!): LoginResponse
  createBucket(data: BucketCreateInput!): BucketResponse!
  createNativeFeed(data: NativeFeedCreateInput!): NativeFeedResponse!
  subscribe(data: SubscribeInput!): SubscriptionResponse!
}

type SubscriptionResponse {
  subscription: SubscriptionDto!
}

type NativeFeedResponse {
  feed: NativeFeed!
}

type BucketResponse {
  bucket: Bucket!
}

type SearchResponse {
  pagination: Pagination!
  matches: [SearchMatch!]
}

type SearchMatch {
  id: String!
  title: String!
  subtitle: String
  url: String!
  score: Float
  createdAt: Long!
}

input SearchInput {
#  bucket: SearchInContextInput
#  feed: SearchInContextInput
#  user: SearchInContextInput
  anywhere: SearchAnywhereInput
}

input SearchAnywhereInput {
  orderBy: [SearchOrderByInput!]
  query: String!
}

input SearchInContextInput {
  id: String!
  orderBy: [SearchOrderByInput!]
  query: String!
}

input SearchOrderByInput {
  createdAt: SortOrder
  score: SortOrder
}

type SubscriptionDto {
  streamId: String!
}

type ArticlesByStreamIdResponse {
  articles: [ArticleInStream!]
  pagination: Pagination!
}

type Pagination {
  page: Int!
  totalPages: Int!
  isLast: Boolean!
  isEmpty: Boolean!
  isFirst: Boolean!
}

input DiscoverFeedsInput {
  url: String!
  prerender: Boolean
  corrId: String
}

input ArticlesByStreamIdFilterInput {
  streamId: String!
  page: Int!
  type: ArticleType!
  status: ReleaseStatus!
}

input SubscribeInput {
  where: BucketOrFeedWhereUniqueInput!
  digest: DigestInput!
  notify: Boolean!
  filter: String
}

input DigestInput {
  daily: Boolean!
  weekly: Boolean!
  monthly: Boolean!
}

input BucketOrFeedWhereUniqueInput {
  bucket: BucketWhereUniqueInput
  feed: NativeFeedWhereUniqueInput
}

input BucketWhereUniqueInput {
  id: String
}

input BucketCreateInput {
  name: String!
  description: String!
  visibility: BucketVisibility!
  releaseManually: Boolean!
  tags: [String]
  subscriptions: [SubscriptionCreateOrConnectWithoutBucketInput!]
  filter: String
  #  exporters: [ExporterData]
}

enum BucketVisibility {
  isPublic,
  isHidden
}

input SubscriptionCreateOrConnectWithoutBucketInput {
  where: SubscriptionWhereUniqueInput!
  create: SubscriptionCreateWithoutBucketInput!
}

input SubscriptionWhereUniqueInput {
  id: String
}

input SubscriptionCreateWithoutBucketInput {
  id: String
  active: Boolean
  title: String!
  #  tags: JSON
  feed: NativeFeedCreateOrConnectInput!
  #  owner: UserConnectInput!
}

input NativeFeedCreateOrConnectInput {
  where: NativeFeedWhereUniqueInput!
  create: NativeFeedCreateInput!
}

input NativeFeedCreateInput {
  id: String
  websiteUrl: String!
  feedUrl: String!
  title: String
  description: String
  harvestSite: Boolean
  harvestSiteWithPrerender: Boolean
}

#input UserConnectInput {
#  where: UserWhereUniqueInput!
#}

input NativeFeedWhereUniqueInput {
  id: String
}

input UserWhereUniqueInput {
  id: String
}

type GenericFeed {
  id: ID!
  feedRule: String!
  nativeFeedId: ID!
}

type NativeFeed {
  id: ID!
  domain: String!
  websiteUrl: String!
  feedUrl: String!
  title: String!
  description: String!
  status: String!
  genericFeed: GenericFeed
  lastUpdatedAt: Long
}

type Bucket {
  id: ID!
  name: String!
  description: String!
  websiteUrl: String
  visibility: BucketVisibility!
  filter: String
  streamId: String!
  lastUpdatedAt: Long
  createdAt: Long!
  importers: [Importer!]
  #  owner
}

type Importer {
  id: String!
  active: Boolean!
  feed: NativeFeed!
}

type Enclosure {
  length: Float
  type: String!
  url: String!
}
type ArticleInStream {
  articleId: ID!
  feedId: ID!
  streamId: ID!
  type: ArticleType!
  status: ReleaseStatus!
  releasedAt: Long!
}
type Article {
  id: ID!
  title: String!
  description: String!
  hasFulltext: Boolean!
  contentTitle: String
  contentText: String!
  contentRaw: String
  contentRawMime: String
  url: String!
  imageUrl: String
  publishedAt: Long!
  updatedAt: Long!
  tags: [String]
  enclosures: [Enclosure!]
}

input PaginationInput {
  page: Int!
  perPage: Int!
}

input Sort {
  field: SortField!
  order: SortOrder!
}

enum SortOrder {
  desc, asc
}

enum SortField {
  publishedAt,

}

type FeedDiscoveryResponse {
  genericFeedRules: [GenericFeedRule!]
  #  relatedFeeds: [NativeFeedGql]
  mimeType: String
  nativeFeeds: [NativeFeedReference!]
  failed: Boolean!
  errorMessage: String
}

type NativeFeedReference {
  url: String!
  type: String!
  title: String!
  description: String
}

type GenericFeedRule {
  linkXPath: String!
  extendContext: String!
  contextXPath: String!
  dateXPath: String
  feedUrl: String!
  count: Int
  score: Float!
}

type FeedReference {
  websiteUrl: String
  feedUrl: String!
  title: String!
  description: String
  lastUpdatedAt: Long
}

type LoginResponse {
  token: String!
  user: User!
}

type User {
  id: String!
  email: String!
  name: String!
  dateFormat: String
  timeFormat: String
}
