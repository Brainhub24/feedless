scalar DateTime
scalar JSON
scalar Long

enum ReleaseStatusGql {
  released,
  needs_approval
}

enum ArticleTypeGql {
  digest
  feed
}

type Query {
  #  bucketOrFeed(count: Int, offset: Int): [BucketGql]!
  articles(filter: ArticlesInStreamFilter!): ArticlesInStreamGql!
  discoverFeeds(data: DiscoverFeedsInput!): FeedDiscoveryGql!
  #  subscriptions: [SubscriptionGql!]!
}

type Mutation {
  login(email: String!): LoginResponse
  createBucket(data: BucketCreateInput!): BucketGql!
  createNativeFeed(data: NativeFeedCreateInput!): NativeFeedGql!
  subscribe(data: SubscribeInput!): SubscriptionGql!
}

type SubscriptionGql {
  streamId: String!
}

type ArticlesInStreamGql {
  articles: [ArticleGql!]
  page: Int!
  totalPages: Int!
  isLast: Boolean!
  isEmpty: Boolean!
  isFirst: Boolean!
}

input DiscoverFeedsInput {
  url: String!
  prerender: Boolean
  corrId: String
}

input ArticlesInStreamFilter {
  id: String!
  page: Int!
  type: ArticleTypeGql!
  status: ReleaseStatusGql!
}

input SubscribeInput {
  where: BucketOrFeedWhereUniqueInput!
  digest: DigestInput!
  notify: Boolean!
  filter: String
}

input DigestInput {
  daily: Boolean!
  weekly: Boolean!
  monthly: Boolean!
}

input BucketOrFeedWhereUniqueInput {
  bucket: BucketWhereUniqueInput
  feed: NativeFeedWhereUniqueInput
}

input BucketWhereUniqueInput {
  id: String
}

input BucketCreateInput {
  name: String!
  description: String!
  visibility: BucketVisibilityGql!
  releaseManually: Boolean!
  tags: [String]
  subscriptions: [SubscriptionCreateOrConnectWithoutBucketInput!]
  filter: String
  #  exporters: [ExporterData]
}

enum BucketVisibilityGql {
  isPublic,
  isHidden
}

input SubscriptionCreateOrConnectWithoutBucketInput {
  where: SubscriptionWhereUniqueInput!
  create: SubscriptionCreateWithoutBucketInput!
}

input SubscriptionWhereUniqueInput {
  id: String
}

input SubscriptionCreateWithoutBucketInput {
  id: String
  active: Boolean
  title: String!
  #  tags: JSON
  feed: NativeFeedCreateOrConnectInput!
  #  owner: UserConnectInput!
}

input NativeFeedCreateOrConnectInput {
  where: NativeFeedWhereUniqueInput!
  create: NativeFeedCreateInput!
}

input NativeFeedCreateInput {
  id: String
  websiteUrl: String!
  feedUrl: String!
  title: String
  description: String
  harvestSite: Boolean
  harvestSiteWithPrerender: Boolean
}

#input UserConnectInput {
#  where: UserWhereUniqueInput!
#}

input NativeFeedWhereUniqueInput {
  id: String
}

input UserWhereUniqueInput {
  id: String
}

type GenericFeedGql {
  id: ID!
}

type NativeFeedGql {
  id: ID!
  domain: String!
  websiteUrl: String!
  feedUrl: String!
  title: String!
  description: String!
  status: String!
  genericFeed: GenericFeedGql
}

type BucketGql {
  id: ID!
  name: String!
  description: String!
  visibility: BucketVisibilityGql!
  filter: String
  lastUpdatedAt: DateTime
  feeds: [NativeFeedGql!]
  #  owner
}

type EnclosureGql {
  length: Float,
  type: String!,
  url: String!
}
type ArticleGql {
  id: ID!
  title: String!
  contentRaw: String
  contentRawMime: String
  contentText: String!
  url: String!
  imageUrl: String
  publishedAt: Float!
  updatedAt: String!
  tags: [String]
  enclosures: [EnclosureGql!]
}

input PaginationGql {
  page: Int!
  perPage: Int!
}

input SortGql {
  field: SortFieldGql!
  order: SortOrderGql!
}

enum SortOrderGql {
  desc, asc
}

enum SortFieldGql {
  publishedAt,

}

type FeedDiscoveryGql {
  genericFeedRules: [GenericFeedRuleGql!]
  #  relatedFeeds: [NativeFeedGql]
  mimeType: String
  nativeFeeds: [NativeFeedReferenceGql!]
  failed: Boolean!
  errorMessage: String
}

type NativeFeedReferenceGql {
  url: String!
  type: String!
  title: String!
  description: String
}

type GenericFeedRuleGql {
  linkXPath: String!
  extendContext: String!
  contextXPath: String!
  dateXPath: String
  feedUrl: String!
  count: Int
  score: Float!
}

type FeedReferenceGql {
  websiteUrl: String
  feedUrl: String!
  title: String!
  description: String
  lastUpdatedAt: Long
}

type LoginResponse {
  token: String!
  user: UserGql!
}

type UserGql {
  id: String!
  email: String!
  name: String!
  dateFormat: String
  timeFormat: String
}
